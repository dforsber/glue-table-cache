import{GetPartitionsCommand as O,GetTableCommand as N,GlueClient as F}from"@aws-sdk/client-glue";import{S3Client as v,ListObjectsV2Command as q}from"@aws-sdk/client-s3";import{LRUCache as $}from"lru-cache";import{DuckDBInstance as x}from"@duckdb/node-api";import _ from"debug";import A from"debug";import S from"jsonpath";var p=A("glue-table-cache:sql"),T=A("glue-table-cache:sql:ast"),d=class{constructor(e){this.db=e}async getQueryAST(e){let t=`SELECT json_serialize_sql('${e.replace(/'/g,"''")}')`;p("Serializing SQL: %s",t);let r=(await this.db.runAndReadAll(t)).getRows();if(!r.length||r[0].length===0||r[0][0]===null)throw new Error("Failed to serialize SQL query");let n=JSON.parse(r[0][0]);if(n.error)throw new Error(JSON.stringify(n));return n}async getSqlFromAst(e){let t=`SELECT json_deserialize_sql('${JSON.stringify(e).replace(/'/g,"''")}')`;p("Deserializing SQL: %s",t);let r=(await this.db.runAndReadAll(t)).getRows();if(!r.length||r[0].length===0||r[0][0]===null)throw new Error("Failed to deserialize SQL query");return r[0][0]+";"}async transformGlueTableQuery(e){p("Transforming query: %s",e);let t=await this.getQueryAST(e);T("Original AST: %O",t),this.transformNode(t),T("Transformed AST: %O",t);let s=await this.getSqlFromAst(t);return p("Transformed query: %s",s),s}async getQueryGlueTableRefs(e){let t=await this.getQueryAST(e);return T("Original AST: %O",t),this.getAstGlueTableRefs(t)}getAstGlueTableRefs(e){return this.getAstTableRefs(e).map(t=>t.tableRef).filter(Boolean)}getAstTableRefs(e){return S.query(e,"$..*[?(@.type=='BASE_TABLE' && (@.catalog_name=='glue' || @.catalog_name=='GLUE'))]").map(n=>({node:n,tableRef:this.getGlueTableRef(n)}))}transformNode(e){p("Finding Glue table references in AST"),T("AST structure:",e);let t=this.getAstTableRefs(e);p("Found %d Glue table references",t.length),T("Table references:",t),S.apply(e,"$..query_location",()=>{});for(let s of t){let r=s.tableRef;r&&(p("Transforming table reference %s.%s",r.database,r.table),Object.assign(s.node,{type:"TABLE_FUNCTION",function:{class:"FUNCTION",type:"FUNCTION",function_name:"parquet_scan",schema:"",catalog:"",children:[{class:"FUNCTION",type:"FUNCTION",function_name:"getvariable",schema:"",catalog:"",children:[{class:"CONSTANT",type:"VALUE_CONSTANT",value:{type:{id:"VARCHAR",type_info:null},is_null:!1,value:`${r.database}_${r.table}_files`}}]}],filter:null,order_bys:{type:"ORDER_MODIFIER",orders:[]},distinct:!1,is_operator:!1,export_state:!1}}))}}getGlueTableRef(e){return e.type==="BASE_TABLE"&&(e.catalog_name==="glue"||e.catalog_name==="GLUE")?{database:e.schema_name||"default",table:e.table_name}:null}async extractPartitionFilters(e,t,s){let r=`SELECT json_serialize_sql('${e.replace(/'/g,"''")}')`;p("Serializing SQL: %s",r);let a=(await this.db.runAndReadAll(r)).getRows();if(!a.length||a[0].length===0||a[0][0]===null)throw new Error("Failed to serialize SQL query");let o=JSON.parse(a[0][0]);if(o.error)throw new Error(JSON.stringify(o));T("Original AST: %O",o);let i=new Set;return o?.statements?.[0]?.node?.where_clause&&this.extractFiltersFromCondition(o.statements[0].node.where_clause,s,i),Array.from(i)}findPartitionFilters(e,t,s,r){if(!(!e||typeof e!="object")){e.type==="SELECT"&&e.where&&this.extractFiltersFromCondition(e.where,s,r);for(let n in e)Array.isArray(e[n])?e[n].forEach(a=>this.findPartitionFilters(a,t,s,r)):typeof e[n]=="object"&&this.findPartitionFilters(e[n],t,s,r)}}extractFiltersFromCondition(e,t,s){if(!(!e||typeof e!="object")){if(e.class==="COMPARISON"){let r=e.left,n=e.right;if(r?.class==="COLUMN_REF"&&t.includes(r.column_names?.[0])&&n?.class==="CONSTANT"&&n?.type==="VALUE_CONSTANT"){let a=n.value?.value;if(a!==void 0){let o=this.getComparisonOperator(e.type),i=typeof a=="string"?`'${a}'`:a;s.add(`${r.column_names[0]} ${o} ${i}`)}}}else if(e.class==="CONJUNCTION")e.children?.forEach(r=>this.extractFiltersFromCondition(r,t,s));else if(e.class==="OPERATOR"&&e.type==="COMPARE_IN"){let r=e.children?.[0];if(r?.class==="COLUMN_REF"&&t.includes(r.column_names?.[0])){let n=e.children.slice(1).filter(a=>a.class==="CONSTANT"&&a.type==="VALUE_CONSTANT").map(a=>`'${a.value.value}'`);n.length>0&&s.add(`${r.column_names[0]} IN (${n.join(", ")})`)}}}}getComparisonOperator(e){switch(e){case"COMPARE_EQUAL":return"=";case"COMPARE_GREATERTHAN":return">";case"COMPARE_LESSTHAN":return"<";case"COMPARE_GREATERTHANOREQUALTO":return">=";case"COMPARE_LESSTHANOREQUALTO":return"<=";case"COMPARE_NOTEQUAL":return"!=";default:throw new Error(`Unsupported comparison type: ${e}`)}}getQueryFilesVarName(e,t){return`${e}_${t}_files`}getGlueTableFilesVarName(e,t){return`${e}_${t}_gview_files`}async getGlueTableViewSql(e){let t=`SELECT json_serialize_sql('${e.replace(/'/g,"''")}')`,r=(await this.db.runAndReadAll(t)).getRows();if(!r.length||r[0].length===0||r[0][0]===null)throw new Error("Failed to serialize SQL query");let n=JSON.parse(r[0][0]);if(n.error)throw new Error(JSON.stringify(n));let a=this.getAstGlueTableRefs(n);if(!a.length)throw new Error("No Glue table references found in query");let o=[],i=new Set;for(let c of a){let h=this.getGlueTableFilesVarName(c.database,c.table),l=`${c.database}_${c.table}`;if(!i.has(l)){i.add(l);let m=`${l}_gview`,u=`SELECT * FROM parquet_scan(getvariable('${h}'))`;o.push(`CREATE OR REPLACE VIEW ${m} AS ${u};`)}}return o}};var g=_("glue-table-cache"),b=_("glue-table-cache:aws"),y={region:"eu-west-1",maxEntries:100,forceRefreshOnError:!0,glueTableMetadataTtlMs:36e5,s3ListingRefreshMs:36e5},C=class{tableCache;s3ListingCache;glueClient;s3Client;db;sqlTransformer;config;constructor(e=y){g("Initializing GlueTableCache for region %s with config %O",e),this.config={...y,...e,region:e?.region||process.env.AWS_REGION||y.region},this.glueClient=new F({region:e.region}),this.s3Client=new v({region:e.region}),this.tableCache=new $({max:this.config.maxEntries,ttl:this.config.glueTableMetadataTtlMs}),this.s3ListingCache=new $({max:this.config.maxEntries,ttl:this.config.s3ListingRefreshMs})}async runAndReadAll(e){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");return this.db.runAndReadAll(e)}async connect(){return this.db||(this.db=await(await x.create(":memory:")).connect()),this.sqlTransformer||(this.sqlTransformer=new d(this.db)),this.db}close(){this.db?.close(),this.db=void 0}async getTableMetadata(e,t){let s=`${e}.${t}`;g("Getting table metadata for %s",s);let r=this.tableCache.get(s);if(!r){g("Cache miss for %s, refreshing...",s);let n=await this.refreshTableMetadata(e,t),o={timestamp:Date.now(),data:n};return this.tableCache.set(s,o),n}return g("Cache hit for %s",s),r.data}async refreshTableMetadata(e,t){try{b("Fetching table metadata from AWS for %s.%s",e,t);let s={DatabaseName:e,Name:t},n=(await this.glueClient.send(new N(s))).Table;if(!n)throw new Error(`Table ${e}.${t} not found`);let a={timestamp:Date.now(),table:n};return n.Parameters?.["projection.enabled"]==="true"?a.projectionPatterns=this.parseProjectionPatterns(n.Parameters):n.PartitionKeys&&n.PartitionKeys.length>0&&(a.partitionMetadata=await this.loadPartitionMetadata(e,t)),a}catch(s){throw this.config.forceRefreshOnError&&this.tableCache.delete(`${e}.${t}`),s}}parseProjectionValue(e,t){switch(e){case"type":return t;case"format":return t;case"range":try{return JSON.parse(t)}catch{return t.split(",").map(s=>s.trim())}case"values":return JSON.parse(t);default:return t}}parseProjectionPatterns(e){let t={};return Object.entries(e).filter(([s])=>s.startsWith("projection.")).forEach(([s,r])=>{let n=s.match(/projection\.(\w+)\.(type|range|format|values)/);if(n){let[a,o,i]=n;t[o]||(t[o]={type:"enum"}),(i==="type"||i==="format"||i==="range"||i==="values")&&(t[o][i]=this.parseProjectionValue(i,r))}}),{enabled:!0,patterns:t}}async loadPartitionMetadata(e,t){let s=new O({DatabaseName:e,TableName:t});try{let r=await this.glueClient.send(s);return!r.Partitions||r.Partitions.length===0?{keys:[],values:[]}:{keys:r.Partitions[0].Values||[],values:r.Partitions.map(n=>({values:n.Values||[],location:n.StorageDescriptor?.Location}))||[]}}catch(r){return console.warn(`Failed to load partitions for ${e}.${t}:`,r),{keys:[],values:[]}}}clearCache(){this.tableCache.clear(),this.s3ListingCache.clear()}invalidateTable(e,t){let s=`${e}.${t}`;this.tableCache.delete(s);for(let r of this.s3ListingCache.keys())r.includes(s)&&this.s3ListingCache.delete(r)}parseS3Path(e){let t=new URL(e);return{bucket:t.hostname,prefix:t.pathname.substring(1)}}extractPartitionValues(e,t){let s={};for(let r of t){let n=e.match(new RegExp(`${r}=([^/]+)`));n&&(s[r]=n[1])}return s}async listS3Files(e,t){let s=`${e}:${t.join(",")}`,r=this.s3ListingCache.get(s);if(r)return b("Using cached S3 listing for %s",e),r.data;b("Listing S3 files for %s",e);let{bucket:n,prefix:a}=this.parseS3Path(e),o=[],i=a.endsWith("/")?a:`${a}/`,c;do{let l=new q({Bucket:n,Prefix:i,ContinuationToken:c,MaxKeys:1e3}),m=await this.s3Client.send(l);if(m.Contents){for(let u of m.Contents)if(u.Key&&!u.Key.includes("_$folder$")){let w=`s3://${n}/${u.Key}`,E=this.extractPartitionValues(w,t);o.push({path:w,partitionValues:E})}}c=m.NextContinuationToken}while(c);let h=Date.now();return this.s3ListingCache.set(s,{timestamp:h,data:o}),o}async getPartitionExtractor(e,t){if(t.projectionPatterns?.enabled){let s=t.projectionPatterns.patterns[e];if(!s)throw new Error(`No projection pattern found for partition key ${e}`);switch(s.type){case"date":let r=s.format||"yyyy-MM-dd";return`regexp_extract(path, '(${this.convertDateFormatToRegex(r)})', 1)`;case"integer":return"CAST(regexp_extract(path, '/([0-9]+)/', 1) AS INTEGER)";case"enum":return"regexp_extract(path, '/([^/]+)/[^/]*$', 1)";case"injected":throw this.sqlTransformer||await this.connect(),this.sqlTransformer?new Error("Injected partition values not supported yet"):new Error("SQL transformer not initialized");default:throw new Error(`Unsupported projection type: ${s.type}`)}}return`regexp_extract(path, '${e}=([^/]+)', 1)`}convertDateFormatToRegex(e){let t={yyyy:"\\d{4}",MM:"\\d{2}",dd:"\\d{2}",HH:"\\d{2}",mm:"\\d{2}",ss:"\\d{2}"},s=e;for(let[r,n]of Object.entries(t))s=s.replace(r,n);return s}async ensureS3ListingTable(e,t,s){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");let r=`${e}.${t}`,n=this.s3ListingCache.get(r),a=Date.now();if(n&&a-n.timestamp<this.config.s3ListingRefreshMs){g("Using cached S3 listing for %s",r);return}g("Refreshing S3 listing for %s",r);let o=s.table.StorageDescriptor?.Location;if(!o)throw new Error(`No storage location found for ${e}.${t}`);let i=(s.table.PartitionKeys||[]).map(l=>l.Name),c=await this.listS3Files(o,i);this.s3ListingCache.set(r,{timestamp:a,data:c}),await this.db.run(`CREATE OR REPLACE TABLE "${r}_s3_files" AS SELECT path FROM (VALUES ${c.map(l=>`('${l.path}')`).join(",")}) t(path);`);let h=await Promise.all(i.map(async l=>`${await this.getPartitionExtractor(l,s)} as ${l}`));await this.db.run(`CREATE OR REPLACE TABLE "${r}_s3_listing" AS SELECT path,  ${h.join(", ")} FROM "${r}_s3_files";`);for(let l of i)await this.db.run(`CREATE INDEX IF NOT EXISTS idx_${l} ON "${r}_s3_listing" (${l});`)}async getS3Locations(e,t,s){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");let r=await this.getTableMetadata(e,t);await this.ensureS3ListingTable(e,t,r);let a=`SELECT DISTINCT path FROM "${`${e}.${t}`}_s3_listing"`;return g(a),s?.sql&&(a+=` WHERE ${s.sql}`),(await this.db.runAndReadAll(a)).getRows().map(i=>String(i[0]))}async getFilteredS3Locations(e,t,s){return this.getS3Locations(e,t,{sql:s.join(" AND ")})}async createGlueTableFilesVarSql(e,t,s){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");if(this.sqlTransformer||(this.sqlTransformer=new d(this.db)),!this.sqlTransformer)throw new Error("SQL transformer not initialized");let n=`SELECT path FROM "${`${e}.${t}`}_s3_listing"`;return s&&s.length>0&&(n+=` WHERE ${s.join(" AND ")}`),`SET VARIABLE ${this.sqlTransformer?.getGlueTableFilesVarName(e,t)} = ( SELECT list(path) FROM (${n}));`}async convertGlueTableQuery(e){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");if(this.sqlTransformer||(this.sqlTransformer=new d(this.db)),!this.sqlTransformer)throw new Error("SQL transformer not initialized");let t=await this.getGlueTableViewSetupSql(e),s=await this.sqlTransformer.transformGlueTableQuery(e);return t.join("")+s}async getGlueTableViewSetupSql(e){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");if(this.sqlTransformer||(this.sqlTransformer=new d(this.db)),!this.sqlTransformer)throw new Error("SQL transformer not initialized");let t=[],s=await this.sqlTransformer.getQueryGlueTableRefs(e);g("Found Glue Table references: %O",s),await Promise.all(s.map(async({database:n,table:a})=>{g("Found Glue Table reference: %s",{database:n,table:a});let o=await this.getTableMetadata(n,a),i=`${n}.${a}`,c=o.table.StorageDescriptor?.Location;if(!c)throw new Error(`No storage location found for ${i}`);let h=(o.table.PartitionKeys||[]).map(f=>f.Name),l=await this.listS3Files(c,h);t.push(`CREATE OR REPLACE TABLE "${i}_s3_files" AS SELECT path FROM (VALUES ${l.map(f=>`('${f.path}')`).join(",")}) t(path);`);let m=await Promise.all(h.map(async f=>`${await this.getPartitionExtractor(f,o)} as ${f}`));t.push(`CREATE OR REPLACE TABLE "${i}_s3_listing" AS SELECT path, ${m.join(", ")} FROM "${i}_s3_files";`);for(let f of h)t.push(`CREATE INDEX IF NOT EXISTS idx_${f} ON "${i}_s3_listing" (${f});`);if(!this.sqlTransformer)throw new Error("SQL transformer not initialized");h=(o.table.PartitionKeys||[]).map(f=>f.Name);let u=await this.sqlTransformer.extractPartitionFilters(e,i,h),w=`SELECT list(path) FROM "${i}_s3_listing"`;u.length>0&&(w+=` WHERE ${u.join(" AND ")}`);let E=this.sqlTransformer.getQueryFilesVarName(n,a);t.push(`SET VARIABLE ${E} = (${w});`);let R=await this.createGlueTableFilesVarSql(n,a);R&&t.push(R);let L=await this.sqlTransformer.getGlueTableViewSql(e);t.push(...L)}));let r=t.map(n=>n.trim());return g(r),r}};export{C as GlueTableCache};
