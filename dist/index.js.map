{
  "version": 3,
  "sources": ["../src/glue-table-cache.ts", "../src/sql-transformer.ts"],
  "sourcesContent": ["import {\n  GetPartitionsCommand,\n  GetTableCommand,\n  GetTableRequest,\n  GlueClient,\n} from \"@aws-sdk/client-glue\";\nimport { S3Client, ListObjectsV2Command } from \"@aws-sdk/client-s3\";\nimport { LRUCache } from \"lru-cache\";\nimport { DuckDBInstance, DuckDBConnection } from \"@duckdb/node-api\";\nimport debug from \"debug\";\nimport { SqlTransformer } from \"./sql-transformer.js\";\nimport {\n  type CachedTableMetadata,\n  type CacheConfig,\n  type CacheEntry,\n  type ProjectionPattern,\n  type S3FileInfo,\n} from \"./types.js\";\nimport { DuckDBResultReader } from \"@duckdb/node-api/lib/DuckDBResultReader.js\";\n\nexport type { S3FileInfo };\n\nconst log = debug(\"glue-table-cache\");\nconst logAws = debug(\"glue-table-cache:aws\");\n\ninterface PartitionFilter {\n  sql: string;\n  parameters?: unknown[];\n}\n\nconst defaultConfig: CacheConfig = {\n  region: \"eu-west-1\",\n  maxEntries: 100,\n  forceRefreshOnError: true,\n  glueTableMetadataTtlMs: 3600000, // 1 hour\n  s3ListingRefreshMs: 3600000, // 1 hour\n};\n\nexport class GlueTableCache {\n  private tableCache: LRUCache<string, CacheEntry<CachedTableMetadata>>;\n  private s3ListingCache: LRUCache<string, CacheEntry<S3FileInfo[]>>;\n  private glueClient: GlueClient;\n  private s3Client: S3Client;\n  private db: DuckDBConnection | undefined;\n  private sqlTransformer: SqlTransformer | undefined;\n  private config: CacheConfig;\n\n  constructor(config: Partial<CacheConfig> = defaultConfig) {\n    log(\"Initializing GlueTableCache for region %s with config %O\", config);\n    this.config = {\n      ...defaultConfig,\n      ...config,\n      region: config?.region || process.env.AWS_REGION || defaultConfig.region,\n    };\n    this.glueClient = new GlueClient({ region: config.region });\n    this.s3Client = new S3Client({ region: config.region });\n\n    // Initialize metadata cache\n    this.tableCache = new LRUCache({\n      max: this.config.maxEntries,\n      ttl: this.config.glueTableMetadataTtlMs,\n    });\n\n    // Initialize S3 listing cache\n    this.s3ListingCache = new LRUCache({\n      max: this.config.maxEntries,\n      ttl: this.config.s3ListingRefreshMs,\n    });\n  }\n\n  // tests use this\n  private async runAndReadAll(query: string): Promise<DuckDBResultReader> {\n    if (!this.db) await this.connect();\n    if (!this.db) throw new Error(\"DB not connected\");\n    return this.db.runAndReadAll(query);\n  }\n\n  private async connect(): Promise<DuckDBConnection> {\n    if (!this.db) this.db = await (await DuckDBInstance.create(\":memory:\")).connect();\n    if (!this.sqlTransformer) this.sqlTransformer = new SqlTransformer(this.db);\n    return this.db;\n  }\n\n  close(): void {\n    this.db?.close();\n    this.db = undefined;\n  }\n\n  async getTableMetadata(database: string, tableName: string): Promise<CachedTableMetadata> {\n    const key = `${database}.${tableName}`;\n    log(\"Getting table metadata for %s\", key);\n    const cached = this.tableCache.get(key);\n\n    if (!cached) {\n      log(\"Cache miss for %s, refreshing...\", key);\n      const metadata = await this.refreshTableMetadata(database, tableName);\n      const now = Date.now();\n      const entry: CacheEntry<CachedTableMetadata> = {\n        timestamp: now,\n        data: metadata,\n      };\n      this.tableCache.set(key, entry);\n      return metadata;\n    }\n\n    log(\"Cache hit for %s\", key);\n    return cached.data;\n  }\n\n  private async refreshTableMetadata(\n    database: string,\n    tableName: string\n  ): Promise<CachedTableMetadata> {\n    try {\n      logAws(\"Fetching table metadata from AWS for %s.%s\", database, tableName);\n      const tableRequest: GetTableRequest = { DatabaseName: database, Name: tableName };\n\n      const tableResponse = await this.glueClient.send(new GetTableCommand(tableRequest));\n      const table = tableResponse.Table;\n\n      if (!table) throw new Error(`Table ${database}.${tableName} not found`);\n      const metadata: CachedTableMetadata = { timestamp: Date.now(), table: table };\n\n      // Handle partition projection if enabled\n      if (table.Parameters?.[\"projection.enabled\"] === \"true\") {\n        metadata.projectionPatterns = this.parseProjectionPatterns(table.Parameters);\n      } else if (table.PartitionKeys && table.PartitionKeys.length > 0) {\n        // Load partition metadata for standard partitioned tables\n        metadata.partitionMetadata = await this.loadPartitionMetadata(database, tableName);\n      }\n\n      return metadata;\n    } catch (error) {\n      if (this.config.forceRefreshOnError) this.tableCache.delete(`${database}.${tableName}`);\n      throw error;\n    }\n  }\n\n  private parseProjectionValue(property: string, value: string): string | string[] | number[] {\n    switch (property) {\n      case \"type\":\n        return value as \"enum\" | \"integer\" | \"date\" | \"injected\";\n      case \"format\":\n        return value;\n      case \"range\":\n        // Handle both JSON array format and comma-separated format\n        try {\n          return JSON.parse(value);\n        } catch {\n          return value.split(\",\").map((v) => v.trim());\n        }\n      case \"values\":\n        return JSON.parse(value);\n      default:\n        return value;\n    }\n  }\n\n  private parseProjectionPatterns(parameters: Record<string, string>): {\n    enabled: boolean;\n    patterns: Record<string, ProjectionPattern>;\n  } {\n    const patterns: Record<string, ProjectionPattern> = {};\n\n    Object.entries(parameters)\n      .filter(([key]) => key.startsWith(\"projection.\"))\n      .forEach(([key, value]) => {\n        const match = key.match(/projection\\.(\\w+)\\.(type|range|format|values)/);\n        if (match) {\n          const [_, column, property] = match;\n          if (!patterns[column]) {\n            patterns[column] = { type: \"enum\" };\n          }\n          if (\n            property === \"type\" ||\n            property === \"format\" ||\n            property === \"range\" ||\n            property === \"values\"\n          ) {\n            (patterns[column] as ProjectionPattern as unknown as Record<string, unknown>)[\n              property\n            ] = this.parseProjectionValue(property, value);\n          }\n        }\n      });\n\n    return {\n      enabled: true,\n      patterns,\n    };\n  }\n\n  private async loadPartitionMetadata(database: string, tableName: string) {\n    // Implementation for loading standard partition metadata\n    const command = new GetPartitionsCommand({\n      DatabaseName: database,\n      TableName: tableName,\n      // Add pagination handling for large partition sets\n    });\n\n    try {\n      const response = await this.glueClient.send(command);\n      if (!response.Partitions || response.Partitions.length === 0) {\n        return { keys: [], values: [] };\n      }\n      return {\n        keys: response.Partitions[0].Values || [],\n        values:\n          response.Partitions.map((p) => ({\n            values: p.Values || [],\n            location: p.StorageDescriptor?.Location,\n          })) || [],\n      };\n    } catch (error) {\n      console.warn(`Failed to load partitions for ${database}.${tableName}:`, error);\n      return { keys: [], values: [] };\n    }\n  }\n\n  // Utility methods for cache management\n  clearCache(): void {\n    this.tableCache.clear();\n    this.s3ListingCache.clear();\n  }\n\n  invalidateTable(database: string, tableName: string): void {\n    const key = `${database}.${tableName}`;\n    this.tableCache.delete(key);\n    // Also invalidate any S3 listings for this table\n    for (const cacheKey of this.s3ListingCache.keys()) {\n      if (cacheKey.includes(key)) {\n        this.s3ListingCache.delete(cacheKey);\n      }\n    }\n  }\n\n  private parseS3Path(s3Path: string): { bucket: string; prefix: string } {\n    const url = new URL(s3Path);\n    return {\n      bucket: url.hostname,\n      prefix: url.pathname.substring(1), // remove leading '/'\n    };\n  }\n\n  private extractPartitionValues(path: string, partitionKeys: string[]): Record<string, string> {\n    const values: Record<string, string> = {};\n    for (const key of partitionKeys) {\n      const match = path.match(new RegExp(`${key}=([^/]+)`));\n      if (match) values[key] = match[1];\n    }\n    return values;\n  }\n\n  private async listS3Files(s3Path: string, partitionKeys: string[]): Promise<S3FileInfo[]> {\n    const cacheKey = `${s3Path}:${partitionKeys.join(\",\")}`;\n    const cached = this.s3ListingCache.get(cacheKey);\n\n    if (cached) {\n      logAws(\"Using cached S3 listing for %s\", s3Path);\n      return cached.data;\n    }\n\n    logAws(\"Listing S3 files for %s\", s3Path);\n    const { bucket, prefix } = this.parseS3Path(s3Path);\n    const files: S3FileInfo[] = [];\n\n    // Ensure prefix ends with \"/\"\n    const normalizedPrefix = prefix.endsWith(\"/\") ? prefix : `${prefix}/`;\n\n    let continuationToken: string | undefined;\n    do {\n      const command = new ListObjectsV2Command({\n        Bucket: bucket,\n        Prefix: normalizedPrefix,\n        ContinuationToken: continuationToken,\n        MaxKeys: 1000,\n      });\n\n      const response = await this.s3Client.send(command);\n\n      if (response.Contents) {\n        for (const object of response.Contents) {\n          if (object.Key && !object.Key.includes(\"_$folder$\")) {\n            const path = `s3://${bucket}/${object.Key}`;\n            const partitionValues = this.extractPartitionValues(path, partitionKeys);\n            files.push({ path, partitionValues });\n          }\n        }\n      }\n\n      continuationToken = response.NextContinuationToken;\n    } while (continuationToken);\n\n    // Cache the results\n    const now = Date.now();\n    this.s3ListingCache.set(cacheKey, { timestamp: now, data: files });\n\n    return files;\n  }\n\n  private async getPartitionExtractor(key: string, metadata: CachedTableMetadata): Promise<string> {\n    // Check if this is a projection-enabled table\n    if (metadata.projectionPatterns?.enabled) {\n      const pattern = metadata.projectionPatterns.patterns[key];\n      if (!pattern) {\n        throw new Error(`No projection pattern found for partition key ${key}`);\n      }\n\n      // Handle different projection types\n      switch (pattern.type) {\n        case \"date\":\n          // For date projections, use the format pattern to build regex\n          const dateFormat = pattern.format || \"yyyy-MM-dd\";\n          const dateRegex = this.convertDateFormatToRegex(dateFormat);\n          return `regexp_extract(path, '(${dateRegex})', 1)`;\n\n        case \"integer\":\n          // For integer projections, extract full numeric values\n          return \"CAST(regexp_extract(path, '/([0-9]+)/', 1) AS INTEGER)\";\n\n        case \"enum\":\n          // For enum projections, extract the last path component before the filename\n          return \"regexp_extract(path, '/([^/]+)/[^/]*$', 1)\";\n\n        case \"injected\":\n          // For injected values, extract them from the SQL query filters\n          // The query must contain static equality conditions\n          if (!this.sqlTransformer) await this.connect();\n          if (!this.sqlTransformer) throw new Error(\"SQL transformer not initialized\");\n          throw new Error(\"Injected partition values not supported yet\");\n\n        default:\n          throw new Error(`Unsupported projection type: ${pattern.type}`);\n      }\n    }\n\n    // Default to Hive-style partitioning\n    return `regexp_extract(path, '${key}=([^/]+)', 1)`;\n  }\n\n  private convertDateFormatToRegex(format: string): string {\n    // Convert Java SimpleDateFormat patterns to regex patterns\n    const conversions: Record<string, string> = {\n      yyyy: \"\\\\d{4}\",\n      MM: \"\\\\d{2}\",\n      dd: \"\\\\d{2}\",\n      HH: \"\\\\d{2}\",\n      mm: \"\\\\d{2}\",\n      ss: \"\\\\d{2}\",\n    };\n\n    let regex = format;\n    for (const [pattern, replacement] of Object.entries(conversions)) {\n      regex = regex.replace(pattern, replacement);\n    }\n    return regex;\n  }\n\n  private async ensureS3ListingTable(\n    database: string,\n    tableName: string,\n    metadata: CachedTableMetadata\n  ): Promise<void> {\n    if (!this.db) await this.connect();\n    if (!this.db) throw new Error(\"DB not connected\");\n    const tblName = `${database}.${tableName}`;\n    const cached = this.s3ListingCache.get(tblName);\n    const now = Date.now();\n\n    if (cached && now - cached.timestamp < this.config.s3ListingRefreshMs) {\n      log(\"Using cached S3 listing for %s\", tblName);\n      return;\n    }\n\n    log(\"Refreshing S3 listing for %s\", tblName);\n    const baseLocation = metadata.table.StorageDescriptor?.Location;\n    if (!baseLocation) {\n      throw new Error(`No storage location found for ${database}.${tableName}`);\n    }\n\n    const partitionKeys = (metadata.table.PartitionKeys || []).map((k) => k.Name!);\n    const files = await this.listS3Files(baseLocation, partitionKeys);\n    this.s3ListingCache.set(tblName, { timestamp: now, data: files });\n\n    // Create base table for file paths\n    await this.db.run(\n      `CREATE OR REPLACE TABLE \"${tblName}_s3_files\" AS ` +\n        `SELECT path FROM (VALUES ${files.map((f) => `('${f.path}')`).join(\",\")}) t(path);`\n    );\n\n    // Create view with partition columns using appropriate extractors\n    const extractors = await Promise.all(\n      partitionKeys.map(async (k) => `${await this.getPartitionExtractor(k, metadata)} as ${k}`)\n    );\n\n    await this.db.run(\n      `CREATE OR REPLACE TABLE \"${tblName}_s3_listing\" AS ` +\n        `SELECT path,  ${extractors.join(\", \")} FROM \"${tblName}_s3_files\";`\n    );\n\n    // Create indexes on partition columns\n    for (const key of partitionKeys) {\n      await this.db.run(\n        `CREATE INDEX IF NOT EXISTS idx_${key} ON \"${tblName}_s3_listing\" (${key});`\n      );\n    }\n  }\n\n  async getS3Locations(\n    database: string,\n    tableName: string,\n    filter?: PartitionFilter\n  ): Promise<string[]> {\n    if (!this.db) await this.connect();\n    if (!this.db) throw new Error(\"DB not connected\");\n    const metadata = await this.getTableMetadata(database, tableName);\n    await this.ensureS3ListingTable(database, tableName, metadata);\n\n    const key = `${database}.${tableName}`;\n    let query = `SELECT DISTINCT path FROM \"${key}_s3_listing\"`;\n    log(query);\n    if (filter?.sql) {\n      query += ` WHERE ${filter.sql}`;\n    }\n\n    const result = await this.db.runAndReadAll(query);\n    // DuckDB returns rows as arrays, where each row is an array of values\n    // First column (index 0) contains our path values\n    return result.getRows().map((row) => String(row[0]));\n  }\n\n  async getFilteredS3Locations(\n    database: string,\n    tableName: string,\n    partitionFilters: string[]\n  ): Promise<string[]> {\n    return this.getS3Locations(database, tableName, {\n      sql: partitionFilters.join(\" AND \"),\n    });\n  }\n\n  async createGlueTableFilesVarSql(\n    database: string,\n    tableName: string,\n    filters?: string[]\n  ): Promise<string> {\n    if (!this.db) await this.connect();\n    if (!this.db) throw new Error(\"DB not connected\");\n    if (!this.sqlTransformer) this.sqlTransformer = new SqlTransformer(this.db);\n    if (!this.sqlTransformer) throw new Error(\"SQL transformer not initialized\");\n    const tblName = `${database}.${tableName}`;\n\n    let query = `SELECT path FROM \"${tblName}_s3_listing\"`;\n    if (filters && filters.length > 0) {\n      query += ` WHERE ${filters.join(\" AND \")}`;\n    }\n\n    // Create a list of paths as a string array\n    const safeVarName = this.sqlTransformer?.getGlueTableFilesVarName(database, tableName);\n    return `SET VARIABLE ${safeVarName} = ( SELECT list(path) FROM (${query}));`;\n  }\n\n  async convertGlueTableQuery(query: string): Promise<string> {\n    if (!this.db) await this.connect();\n    if (!this.db) throw new Error(\"DB not connected\");\n    if (!this.sqlTransformer) this.sqlTransformer = new SqlTransformer(this.db);\n    if (!this.sqlTransformer) throw new Error(\"SQL transformer not initialized\");\n\n    const setupSql = await this.getGlueTableViewSetupSql(query);\n    const transformedQuery = await this.sqlTransformer.transformGlueTableQuery(query);\n    return setupSql.join(\"\") + transformedQuery;\n  }\n\n  private async getGlueTableViewSetupSql(query: string): Promise<string[]> {\n    if (!this.db) await this.connect();\n    if (!this.db) throw new Error(\"DB not connected\");\n    if (!this.sqlTransformer) this.sqlTransformer = new SqlTransformer(this.db);\n    if (!this.sqlTransformer) throw new Error(\"SQL transformer not initialized\");\n\n    // Generate all SQL statements needed\n    const statements: string[] = [];\n\n    // Get Glue Table references from the query\n    const tableRefs = await this.sqlTransformer.getQueryGlueTableRefs(query);\n    log(\"Found Glue Table references: %O\", tableRefs);\n    await Promise.all(\n      tableRefs.map(async ({ database, table }) => {\n        log(\"Found Glue Table reference: %s\", { database, table });\n\n        const metadata = await this.getTableMetadata(database, table);\n        const tblName = `${database}.${table}`;\n        const baseLocation = metadata.table.StorageDescriptor?.Location;\n        if (!baseLocation) {\n          throw new Error(`No storage location found for ${tblName}`);\n        }\n\n        let partitionKeys = (metadata.table.PartitionKeys || []).map((k) => k.Name!);\n        const files = await this.listS3Files(baseLocation, partitionKeys);\n\n        // 1. Create base table for file paths\n        statements.push(\n          `CREATE OR REPLACE TABLE \"${tblName}_s3_files\" AS ` +\n            `SELECT path FROM (VALUES ${files.map((f) => `('${f.path}')`).join(\",\")}) t(path);`\n        );\n\n        // 2. Create listing table with partition columns\n        const extractors = await Promise.all(\n          partitionKeys.map(async (k) => `${await this.getPartitionExtractor(k, metadata)} as ${k}`)\n        );\n\n        statements.push(\n          `CREATE OR REPLACE TABLE \"${tblName}_s3_listing\" AS ` +\n            `SELECT path, ${extractors.join(\", \")} FROM \"${tblName}_s3_files\";`\n        );\n\n        // 3. Create indexes on partition columns\n        for (const key of partitionKeys) {\n          statements.push(\n            `CREATE INDEX IF NOT EXISTS idx_${key} ON \"${tblName}_s3_listing\" (${key});`\n          );\n        }\n\n        // 4. Extract partition filters from the query and set the variable with filtered file list\n        if (!this.sqlTransformer) throw new Error(\"SQL transformer not initialized\"); // make TS happy\n        partitionKeys = (metadata.table.PartitionKeys || []).map((k) => k.Name!);\n        const partitionFilters = await this.sqlTransformer.extractPartitionFilters(\n          query,\n          tblName,\n          partitionKeys\n        );\n\n        // 5. Query specific partition pruned SQL VARIABLE\n        let variableQuery = `SELECT list(path) FROM \"${tblName}_s3_listing\"`;\n        if (partitionFilters.length > 0) {\n          variableQuery += ` WHERE ${partitionFilters.join(\" AND \")}`;\n        }\n        const queryVarName = this.sqlTransformer.getQueryFilesVarName(database, table);\n        statements.push(`SET VARIABLE ${queryVarName} = (${variableQuery});`);\n\n        // 6. Unfiltered Glue Table VIEW\n        const glueTableViewSql = await this.createGlueTableFilesVarSql(database, table);\n        if (glueTableViewSql) statements.push(glueTableViewSql);\n\n        const viewSqls = await this.sqlTransformer.getGlueTableViewSql(query);\n        statements.push(...viewSqls);\n      })\n    );\n\n    const trimmed = statements.map((stmt) => stmt.trim());\n    log(trimmed);\n    return trimmed;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { DuckDBConnection } from \"@duckdb/node-api\";\nimport { TableReference } from \"./types.js\";\nimport debug from \"debug\";\nimport jp from \"jsonpath\";\n\nconst log = debug(\"glue-table-cache:sql\");\nconst logAst = debug(\"glue-table-cache:sql:ast\");\n\nexport class SqlTransformer {\n  constructor(private db: DuckDBConnection) {}\n\n  private async getQueryAST(query: string): Promise<any> {\n    // Get the AST in JSON format\n    const sqlCmd = `SELECT json_serialize_sql('${query.replace(/'/g, \"''\")}')`;\n    log(\"Serializing SQL: %s\", sqlCmd);\n    const result = await this.db.runAndReadAll(sqlCmd);\n    const rows = result.getRows();\n    if (!rows.length || rows[0].length === 0 || rows[0][0] === null) {\n      throw new Error(\"Failed to serialize SQL query\");\n    }\n    const ast = JSON.parse(rows[0][0] as string);\n    if (ast.error) throw new Error(JSON.stringify(ast));\n    return ast;\n  }\n\n  private async getSqlFromAst(ast: any): Promise<string> {\n    const deserializeCmd = `SELECT json_deserialize_sql('${JSON.stringify(ast).replace(/'/g, \"''\")}')`;\n    log(\"Deserializing SQL: %s\", deserializeCmd);\n    const transformed = await this.db.runAndReadAll(deserializeCmd);\n    const rows = transformed.getRows();\n    if (!rows.length || rows[0].length === 0 || rows[0][0] === null) {\n      throw new Error(\"Failed to deserialize SQL query\");\n    }\n    return (rows[0][0] as string) + \";\";\n  }\n\n  async transformGlueTableQuery(query: string): Promise<string> {\n    log(\"Transforming query: %s\", query);\n\n    // Get the AST in JSON format\n    const ast = await this.getQueryAST(query);\n    logAst(\"Original AST: %O\", ast);\n\n    // Transform the AST\n    this.transformNode(ast);\n    logAst(\"Transformed AST: %O\", ast);\n\n    // Convert back to SQL\n    const sql = await this.getSqlFromAst(ast);\n    log(\"Transformed query: %s\", sql);\n\n    return sql;\n  }\n\n  public async getQueryGlueTableRefs(query: string): Promise<TableReference[]> {\n    // Get the AST in JSON format\n    const ast = await this.getQueryAST(query);\n    logAst(\"Original AST: %O\", ast);\n    return this.getAstGlueTableRefs(ast);\n  }\n\n  private getAstGlueTableRefs(ast: string): TableReference[] {\n    return this.getAstTableRefs(ast)\n      .map((ref) => ref.tableRef)\n      .filter(Boolean);\n  }\n\n  private getAstTableRefs(ast: any): any[] {\n    const pathExpr =\n      \"$..*[?(@.type=='BASE_TABLE' && (@.catalog_name=='glue' || @.catalog_name=='GLUE'))]\";\n    const tableRefPaths = jp.query(ast, pathExpr);\n    const glueRefs = tableRefPaths.map((node) => ({ node, tableRef: this.getGlueTableRef(node) }));\n    return glueRefs;\n  }\n\n  private transformNode(ast: any): void {\n    log(\"Finding Glue table references in AST\");\n    logAst(\"AST structure:\", ast);\n\n    // Find all Glue table references using JSONPath\n    const tableRefs = this.getAstTableRefs(ast);\n    log(\"Found %d Glue table references\", tableRefs.length);\n    logAst(\"Table references:\", tableRefs);\n\n    // Remove all query_location keys\n    jp.apply(ast, \"$..query_location\", () => undefined);\n\n    // Transform each table reference\n    for (const ref of tableRefs) {\n      const tableRef = ref.tableRef;\n      if (tableRef) {\n        log(\"Transforming table reference %s.%s\", tableRef.database, tableRef.table);\n        // Replace with parquet_scan function call\n        Object.assign(ref.node, {\n          type: \"TABLE_FUNCTION\",\n          function: {\n            class: \"FUNCTION\",\n            type: \"FUNCTION\",\n            function_name: \"parquet_scan\",\n            schema: \"\",\n            catalog: \"\",\n            children: [\n              {\n                class: \"FUNCTION\",\n                type: \"FUNCTION\",\n                function_name: \"getvariable\",\n                schema: \"\",\n                catalog: \"\",\n                children: [\n                  {\n                    class: \"CONSTANT\",\n                    type: \"VALUE_CONSTANT\",\n                    value: {\n                      type: {\n                        id: \"VARCHAR\",\n                        type_info: null,\n                      },\n                      is_null: false,\n                      value: `${tableRef.database}_${tableRef.table}_files`,\n                    },\n                  },\n                ],\n              },\n            ],\n            filter: null,\n            order_bys: { type: \"ORDER_MODIFIER\", orders: [] },\n            distinct: false,\n            is_operator: false,\n            export_state: false,\n          },\n        });\n      }\n    }\n  }\n\n  private getGlueTableRef(node: any): TableReference | null {\n    if (\n      node.type === \"BASE_TABLE\" &&\n      (node.catalog_name === \"glue\" || node.catalog_name === \"GLUE\")\n    ) {\n      return {\n        database: node.schema_name || \"default\",\n        table: node.table_name,\n      };\n    }\n    return null;\n  }\n\n  async extractPartitionFilters(\n    query: string,\n    tableName: string,\n    partitionKeys: string[]\n  ): Promise<string[]> {\n    // Get the AST in JSON format\n    const sqlCmd = `SELECT json_serialize_sql('${query.replace(/'/g, \"''\")}')`;\n    log(\"Serializing SQL: %s\", sqlCmd);\n    const result = await this.db.runAndReadAll(sqlCmd);\n    const rows = result.getRows();\n    if (!rows.length || rows[0].length === 0 || rows[0][0] === null) {\n      throw new Error(\"Failed to serialize SQL query\");\n    }\n    const ast = JSON.parse(rows[0][0] as string);\n    if (ast.error) throw new Error(JSON.stringify(ast));\n    logAst(\"Original AST: %O\", ast);\n\n    const filters: Set<string> = new Set();\n    if (ast?.statements?.[0]?.node?.where_clause) {\n      this.extractFiltersFromCondition(ast.statements[0].node.where_clause, partitionKeys, filters);\n    }\n    return Array.from(filters);\n  }\n\n  private findPartitionFilters(\n    node: any,\n    tableName: string,\n    partitionKeys: string[],\n    filters: Set<string>\n  ): void {\n    if (!node || typeof node !== \"object\") return;\n\n    // Check if this is a WHERE clause\n    if (node.type === \"SELECT\" && node.where) {\n      this.extractFiltersFromCondition(node.where, partitionKeys, filters);\n    }\n\n    // Recursively process all properties\n    for (const key in node) {\n      if (Array.isArray(node[key])) {\n        node[key].forEach((child: any) =>\n          this.findPartitionFilters(child, tableName, partitionKeys, filters)\n        );\n      } else if (typeof node[key] === \"object\") {\n        this.findPartitionFilters(node[key], tableName, partitionKeys, filters);\n      }\n    }\n  }\n\n  private extractFiltersFromCondition(\n    condition: any,\n    partitionKeys: string[],\n    filters: Set<string>\n  ): void {\n    if (!condition || typeof condition !== \"object\") return;\n\n    // Handle COMPARISON nodes\n    if (condition.class === \"COMPARISON\") {\n      const left = condition.left;\n      const right = condition.right;\n      if (\n        left?.class === \"COLUMN_REF\" &&\n        partitionKeys.includes(left.column_names?.[0]) &&\n        right?.class === \"CONSTANT\" &&\n        right?.type === \"VALUE_CONSTANT\"\n      ) {\n        const value = right.value?.value;\n        if (value !== undefined) {\n          const operator = this.getComparisonOperator(condition.type);\n          const quotedValue = typeof value === \"string\" ? `'${value}'` : value;\n          filters.add(`${left.column_names[0]} ${operator} ${quotedValue}`);\n        }\n      }\n    }\n    // Handle CONJUNCTION nodes (AND/OR)\n    else if (condition.class === \"CONJUNCTION\") {\n      condition.children?.forEach((child: any) =>\n        this.extractFiltersFromCondition(child, partitionKeys, filters)\n      );\n    }\n    // Handle IN conditions\n    else if (condition.class === \"OPERATOR\" && condition.type === \"COMPARE_IN\") {\n      const left = condition.children?.[0];\n      if (left?.class === \"COLUMN_REF\" && partitionKeys.includes(left.column_names?.[0])) {\n        const values = condition.children\n          .slice(1)\n          .filter((c: any) => c.class === \"CONSTANT\" && c.type === \"VALUE_CONSTANT\")\n          .map((c: any) => `'${c.value.value}'`);\n        if (values.length > 0) {\n          filters.add(`${left.column_names[0]} IN (${values.join(\", \")})`);\n        }\n      }\n    }\n  }\n\n  private getComparisonOperator(type: string): string {\n    switch (type) {\n      case \"COMPARE_EQUAL\":\n        return \"=\";\n      case \"COMPARE_GREATERTHAN\":\n        return \">\";\n      case \"COMPARE_LESSTHAN\":\n        return \"<\";\n      case \"COMPARE_GREATERTHANOREQUALTO\":\n        return \">=\";\n      case \"COMPARE_LESSTHANOREQUALTO\":\n        return \"<=\";\n      case \"COMPARE_NOTEQUAL\":\n        return \"!=\";\n      default:\n        throw new Error(`Unsupported comparison type: ${type}`);\n    }\n  }\n\n  public getQueryFilesVarName(database: string, table: string): string {\n    return `${database}_${table}_files`;\n  }\n\n  public getGlueTableFilesVarName(database: string, table: string): string {\n    return `${database}_${table}_gview_files`;\n  }\n\n  async getGlueTableViewSql(query: string): Promise<string[]> {\n    // Get the AST in JSON format to extract table references\n    const sqlCmd = `SELECT json_serialize_sql('${query.replace(/'/g, \"''\")}')`;\n    const result = await this.db.runAndReadAll(sqlCmd);\n    const rows = result.getRows();\n    if (!rows.length || rows[0].length === 0 || rows[0][0] === null) {\n      throw new Error(\"Failed to serialize SQL query\");\n    }\n    const ast = JSON.parse(rows[0][0] as string);\n    if (ast.error) throw new Error(JSON.stringify(ast));\n\n    // Find all Glue table references\n    const tableRefs = this.getAstGlueTableRefs(ast);\n    if (!tableRefs.length) throw new Error(\"No Glue table references found in query\");\n\n    // Create a view for each unique table reference\n    const views: string[] = [];\n    const processedTables = new Set<string>();\n\n    for (const ref of tableRefs) {\n      const glueTablVarName = this.getGlueTableFilesVarName(ref.database, ref.table);\n      const tableKey = `${ref.database}_${ref.table}`;\n      if (!processedTables.has(tableKey)) {\n        processedTables.add(tableKey);\n        const tableViewName = `${tableKey}_gview`;\n        const baseQuery = `SELECT * FROM parquet_scan(getvariable('${glueTablVarName}'))`;\n        views.push(`CREATE OR REPLACE VIEW ${tableViewName} AS ${baseQuery};`);\n      }\n    }\n\n    return views;\n  }\n}\n"],
  "mappings": "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",
  "names": ["GetPartitionsCommand", "GetTableCommand", "GlueClient", "S3Client", "ListObjectsV2Command", "LRUCache", "DuckDBInstance", "debug", "debug", "jp", "log", "logAst", "SqlTransformer", "db", "query", "sqlCmd", "rows", "ast", "deserializeCmd", "sql", "ref", "node", "tableRefs", "tableRef", "tableName", "partitionKeys", "filters", "key", "child", "condition", "left", "right", "value", "operator", "quotedValue", "values", "c", "type", "database", "table", "views", "processedTables", "glueTablVarName", "tableKey", "tableViewName", "baseQuery", "log", "debug", "logAws", "defaultConfig", "GlueTableCache", "config", "__publicField", "GlueClient", "S3Client", "LRUCache", "query", "DuckDBInstance", "SqlTransformer", "database", "tableName", "key", "cached", "metadata", "entry", "tableRequest", "table", "GetTableCommand", "error", "property", "value", "v", "parameters", "patterns", "match", "_", "column", "command", "GetPartitionsCommand", "response", "p", "cacheKey", "s3Path", "url", "path", "partitionKeys", "values", "bucket", "prefix", "files", "normalizedPrefix", "continuationToken", "ListObjectsV2Command", "object", "partitionValues", "now", "pattern", "dateFormat", "format", "conversions", "regex", "replacement", "tblName", "baseLocation", "k", "f", "extractors", "filter", "row", "partitionFilters", "filters", "setupSql", "transformedQuery", "statements", "tableRefs", "variableQuery", "queryVarName", "glueTableViewSql", "viewSqls", "trimmed", "stmt"]
}
