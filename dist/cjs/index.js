"use strict";var M=Object.create;var y=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var G=Object.getPrototypeOf,V=Object.prototype.hasOwnProperty;var I=(c,e)=>{for(var t in e)y(c,t,{get:e[t],enumerable:!0})},v=(c,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of D(e))!V.call(c,r)&&r!==t&&y(c,r,{get:()=>e[r],enumerable:!(s=j(e,r))||s.enumerable});return c};var A=(c,e,t)=>(t=c!=null?M(G(c)):{},v(e||!c||!c.__esModule?y(t,"default",{value:c,enumerable:!0}):t,c)),Q=c=>v(y({},"__esModule",{value:!0}),c);var k={};I(k,{GlueTableCache:()=>C});module.exports=Q(k);var E=require("@aws-sdk/client-glue"),R=require("@aws-sdk/client-s3"),O=require("lru-cache"),q=require("@duckdb/node-api"),N=A(require("debug"),1);var _=A(require("debug"),1),$=A(require("jsonpath"),1),m=(0,_.default)("glue-table-cache:sql"),w=(0,_.default)("glue-table-cache:sql:ast"),T=class{constructor(e){this.db=e}async getQueryAST(e){let t=`SELECT json_serialize_sql('${e.replace(/'/g,"''")}')`;m("Serializing SQL: %s",t);let r=(await this.db.runAndReadAll(t)).getRows();if(!r.length||r[0].length===0||r[0][0]===null)throw new Error("Failed to serialize SQL query");let n=JSON.parse(r[0][0]);if(n.error)throw new Error(JSON.stringify(n));return n}async getSqlFromAst(e){let t=`SELECT json_deserialize_sql('${JSON.stringify(e).replace(/'/g,"''")}')`;m("Deserializing SQL: %s",t);let r=(await this.db.runAndReadAll(t)).getRows();if(!r.length||r[0].length===0||r[0][0]===null)throw new Error("Failed to deserialize SQL query");return r[0][0]+";"}async transformGlueTableQuery(e){m("Transforming query: %s",e);let t=await this.getQueryAST(e);w("Original AST: %O",t),this.transformNode(t),w("Transformed AST: %O",t);let s=await this.getSqlFromAst(t);return m("Transformed query: %s",s),s}async getQueryGlueTableRefs(e){let t=await this.getQueryAST(e);return w("Original AST: %O",t),this.getAstGlueTableRefs(t)}getAstGlueTableRefs(e){return this.getAstTableRefs(e).map(t=>t.tableRef).filter(Boolean)}getAstTableRefs(e){return $.default.query(e,"$..*[?(@.type=='BASE_TABLE' && (@.catalog_name=='glue' || @.catalog_name=='GLUE'))]").map(n=>({node:n,tableRef:this.getGlueTableRef(n)}))}transformNode(e){m("Finding Glue table references in AST"),w("AST structure:",e);let t=this.getAstTableRefs(e);m("Found %d Glue table references",t.length),w("Table references:",t),$.default.apply(e,"$..query_location",()=>{});for(let s of t){let r=s.tableRef;r&&(m("Transforming table reference %s.%s",r.database,r.table),Object.assign(s.node,{type:"TABLE_FUNCTION",function:{class:"FUNCTION",type:"FUNCTION",function_name:"parquet_scan",schema:"",catalog:"",children:[{class:"FUNCTION",type:"FUNCTION",function_name:"getvariable",schema:"",catalog:"",children:[{class:"CONSTANT",type:"VALUE_CONSTANT",value:{type:{id:"VARCHAR",type_info:null},is_null:!1,value:`${r.database}_${r.table}_files`}}]}],filter:null,order_bys:{type:"ORDER_MODIFIER",orders:[]},distinct:!1,is_operator:!1,export_state:!1}}))}}getGlueTableRef(e){return e.type==="BASE_TABLE"&&(e.catalog_name==="glue"||e.catalog_name==="GLUE")?{database:e.schema_name||"default",table:e.table_name}:null}async extractPartitionFilters(e,t,s){let r=`SELECT json_serialize_sql('${e.replace(/'/g,"''")}')`;m("Serializing SQL: %s",r);let a=(await this.db.runAndReadAll(r)).getRows();if(!a.length||a[0].length===0||a[0][0]===null)throw new Error("Failed to serialize SQL query");let o=JSON.parse(a[0][0]);if(o.error)throw new Error(JSON.stringify(o));w("Original AST: %O",o);let i=new Set;return o?.statements?.[0]?.node?.where_clause&&this.extractFiltersFromCondition(o.statements[0].node.where_clause,s,i),Array.from(i)}findPartitionFilters(e,t,s,r){if(!(!e||typeof e!="object")){e.type==="SELECT"&&e.where&&this.extractFiltersFromCondition(e.where,s,r);for(let n in e)Array.isArray(e[n])?e[n].forEach(a=>this.findPartitionFilters(a,t,s,r)):typeof e[n]=="object"&&this.findPartitionFilters(e[n],t,s,r)}}extractFiltersFromCondition(e,t,s){if(!(!e||typeof e!="object")){if(e.class==="COMPARISON"){let r=e.left,n=e.right;if(r?.class==="COLUMN_REF"&&t.includes(r.column_names?.[0])&&n?.class==="CONSTANT"&&n?.type==="VALUE_CONSTANT"){let a=n.value?.value;if(a!==void 0){let o=this.getComparisonOperator(e.type),i=typeof a=="string"?`'${a}'`:a;s.add(`${r.column_names[0]} ${o} ${i}`)}}}else if(e.class==="CONJUNCTION")e.children?.forEach(r=>this.extractFiltersFromCondition(r,t,s));else if(e.class==="OPERATOR"&&e.type==="COMPARE_IN"){let r=e.children?.[0];if(r?.class==="COLUMN_REF"&&t.includes(r.column_names?.[0])){let n=e.children.slice(1).filter(a=>a.class==="CONSTANT"&&a.type==="VALUE_CONSTANT").map(a=>`'${a.value.value}'`);n.length>0&&s.add(`${r.column_names[0]} IN (${n.join(", ")})`)}}}}getComparisonOperator(e){switch(e){case"COMPARE_EQUAL":return"=";case"COMPARE_GREATERTHAN":return">";case"COMPARE_LESSTHAN":return"<";case"COMPARE_GREATERTHANOREQUALTO":return">=";case"COMPARE_LESSTHANOREQUALTO":return"<=";case"COMPARE_NOTEQUAL":return"!=";default:throw new Error(`Unsupported comparison type: ${e}`)}}getQueryFilesVarName(e,t){return`${e}_${t}_files`}getGlueTableFilesVarName(e,t){return`${e}_${t}_gview_files`}async getGlueTableViewSql(e){let t=`SELECT json_serialize_sql('${e.replace(/'/g,"''")}')`,r=(await this.db.runAndReadAll(t)).getRows();if(!r.length||r[0].length===0||r[0][0]===null)throw new Error("Failed to serialize SQL query");let n=JSON.parse(r[0][0]);if(n.error)throw new Error(JSON.stringify(n));let a=this.getAstGlueTableRefs(n);if(!a.length)throw new Error("No Glue table references found in query");let o=[],i=new Set;for(let h of a){let f=this.getGlueTableFilesVarName(h.database,h.table),l=`${h.database}_${h.table}`;if(!i.has(l)){i.add(l);let d=`${l}_gview`,p=`SELECT * FROM parquet_scan(getvariable('${f}'))`;o.push(`CREATE OR REPLACE VIEW ${d} AS ${p};`)}}return o}};var u=(0,N.default)("glue-table-cache"),P=(0,N.default)("glue-table-cache:aws"),L={region:"eu-west-1",maxEntries:100,forceRefreshOnError:!0,glueTableMetadataTtlMs:36e5,s3ListingRefreshMs:36e5},C=class{tableCache;s3ListingCache;glueClient;s3Client;db;sqlTransformer;config;constructor(e=L){u("Initializing GlueTableCache for region %s with config %O",e),this.config={...L,...e,region:e?.region||process.env.AWS_REGION||L.region},this.glueClient=new E.GlueClient({region:e.region}),this.s3Client=new R.S3Client({region:e.region}),this.tableCache=new O.LRUCache({max:this.config.maxEntries,ttl:this.config.glueTableMetadataTtlMs}),this.s3ListingCache=new O.LRUCache({max:this.config.maxEntries,ttl:this.config.s3ListingRefreshMs})}async runAndReadAll(e){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");return this.db.runAndReadAll(e)}async connect(){return this.db||(this.db=await(await q.DuckDBInstance.create(":memory:")).connect()),this.sqlTransformer||(this.sqlTransformer=new T(this.db)),this.db}close(){this.db?.close(),this.db=void 0}async getTableMetadata(e,t){let s=`${e}.${t}`;u("Getting table metadata for %s",s);let r=this.tableCache.get(s);if(!r){u("Cache miss for %s, refreshing...",s);let n=await this.refreshTableMetadata(e,t),o={timestamp:Date.now(),data:n};return this.tableCache.set(s,o),n}return u("Cache hit for %s",s),r.data}async refreshTableMetadata(e,t){try{P("Fetching table metadata from AWS for %s.%s",e,t);let s={DatabaseName:e,Name:t},n=(await this.glueClient.send(new E.GetTableCommand(s))).Table;if(!n)throw new Error(`Table ${e}.${t} not found`);let a={timestamp:Date.now(),table:n};return n.Parameters?.["projection.enabled"]==="true"?a.projectionPatterns=this.parseProjectionPatterns(n.Parameters):n.PartitionKeys&&n.PartitionKeys.length>0&&(a.partitionMetadata=await this.loadPartitionMetadata(e,t)),a}catch(s){throw this.config.forceRefreshOnError&&this.tableCache.delete(`${e}.${t}`),s}}parseProjectionValue(e,t){switch(e){case"type":return t;case"format":return t;case"range":try{return JSON.parse(t)}catch{return t.split(",").map(s=>s.trim())}case"values":return JSON.parse(t);default:return t}}parseProjectionPatterns(e){let t={};return Object.entries(e).filter(([s])=>s.startsWith("projection.")).forEach(([s,r])=>{let n=s.match(/projection\.(\w+)\.(type|range|format|values)/);if(n){let[a,o,i]=n;t[o]||(t[o]={type:"enum"}),(i==="type"||i==="format"||i==="range"||i==="values")&&(t[o][i]=this.parseProjectionValue(i,r))}}),{enabled:!0,patterns:t}}async loadPartitionMetadata(e,t){let s=new E.GetPartitionsCommand({DatabaseName:e,TableName:t});try{let r=await this.glueClient.send(s);return!r.Partitions||r.Partitions.length===0?{keys:[],values:[]}:{keys:r.Partitions[0].Values||[],values:r.Partitions.map(n=>({values:n.Values||[],location:n.StorageDescriptor?.Location}))||[]}}catch(r){return console.warn(`Failed to load partitions for ${e}.${t}:`,r),{keys:[],values:[]}}}clearCache(){this.tableCache.clear(),this.s3ListingCache.clear()}invalidateTable(e,t){let s=`${e}.${t}`;this.tableCache.delete(s);for(let r of this.s3ListingCache.keys())r.includes(s)&&this.s3ListingCache.delete(r)}parseS3Path(e){let t=new URL(e);return{bucket:t.hostname,prefix:t.pathname.substring(1)}}extractPartitionValues(e,t){let s={};for(let r of t){let n=e.match(new RegExp(`${r}=([^/]+)`));n&&(s[r]=n[1])}return s}async listS3Files(e,t){let s=`${e}:${t.join(",")}`,r=this.s3ListingCache.get(s);if(r)return P("Using cached S3 listing for %s",e),r.data;P("Listing S3 files for %s",e);let{bucket:n,prefix:a}=this.parseS3Path(e),o=[],i=a.endsWith("/")?a:`${a}/`,h;do{let l=new R.ListObjectsV2Command({Bucket:n,Prefix:i,ContinuationToken:h,MaxKeys:1e3}),d=await this.s3Client.send(l);if(d.Contents){for(let p of d.Contents)if(p.Key&&!p.Key.includes("_$folder$")){let b=`s3://${n}/${p.Key}`,S=this.extractPartitionValues(b,t);o.push({path:b,partitionValues:S})}}h=d.NextContinuationToken}while(h);let f=Date.now();return this.s3ListingCache.set(s,{timestamp:f,data:o}),o}async getPartitionExtractor(e,t){if(t.projectionPatterns?.enabled){let s=t.projectionPatterns.patterns[e];if(!s)throw new Error(`No projection pattern found for partition key ${e}`);switch(s.type){case"date":let r=s.format||"yyyy-MM-dd";return`regexp_extract(path, '(${this.convertDateFormatToRegex(r)})', 1)`;case"integer":return"CAST(regexp_extract(path, '/([0-9]+)/', 1) AS INTEGER)";case"enum":return"regexp_extract(path, '/([^/]+)/[^/]*$', 1)";case"injected":throw this.sqlTransformer||await this.connect(),this.sqlTransformer?new Error("Injected partition values not supported yet"):new Error("SQL transformer not initialized");default:throw new Error(`Unsupported projection type: ${s.type}`)}}return`regexp_extract(path, '${e}=([^/]+)', 1)`}convertDateFormatToRegex(e){let t={yyyy:"\\d{4}",MM:"\\d{2}",dd:"\\d{2}",HH:"\\d{2}",mm:"\\d{2}",ss:"\\d{2}"},s=e;for(let[r,n]of Object.entries(t))s=s.replace(r,n);return s}async ensureS3ListingTable(e,t,s){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");let r=`${e}.${t}`,n=this.s3ListingCache.get(r),a=Date.now();if(n&&a-n.timestamp<this.config.s3ListingRefreshMs){u("Using cached S3 listing for %s",r);return}u("Refreshing S3 listing for %s",r);let o=s.table.StorageDescriptor?.Location;if(!o)throw new Error(`No storage location found for ${e}.${t}`);let i=(s.table.PartitionKeys||[]).map(l=>l.Name),h=await this.listS3Files(o,i);this.s3ListingCache.set(r,{timestamp:a,data:h}),await this.db.run(`CREATE OR REPLACE TABLE "${r}_s3_files" AS SELECT path FROM (VALUES ${h.map(l=>`('${l.path}')`).join(",")}) t(path);`);let f=await Promise.all(i.map(async l=>`${await this.getPartitionExtractor(l,s)} as ${l}`));await this.db.run(`CREATE OR REPLACE TABLE "${r}_s3_listing" AS SELECT path,  ${f.join(", ")} FROM "${r}_s3_files";`);for(let l of i)await this.db.run(`CREATE INDEX IF NOT EXISTS idx_${l} ON "${r}_s3_listing" (${l});`)}async getS3Locations(e,t,s){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");let r=await this.getTableMetadata(e,t);await this.ensureS3ListingTable(e,t,r);let a=`SELECT DISTINCT path FROM "${`${e}.${t}`}_s3_listing"`;return u(a),s?.sql&&(a+=` WHERE ${s.sql}`),(await this.db.runAndReadAll(a)).getRows().map(i=>String(i[0]))}async getFilteredS3Locations(e,t,s){return this.getS3Locations(e,t,{sql:s.join(" AND ")})}async createGlueTableFilesVarSql(e,t,s){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");if(this.sqlTransformer||(this.sqlTransformer=new T(this.db)),!this.sqlTransformer)throw new Error("SQL transformer not initialized");let n=`SELECT path FROM "${`${e}.${t}`}_s3_listing"`;return s&&s.length>0&&(n+=` WHERE ${s.join(" AND ")}`),`SET VARIABLE ${this.sqlTransformer?.getGlueTableFilesVarName(e,t)} = ( SELECT list(path) FROM (${n}));`}async convertGlueTableQuery(e){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");if(this.sqlTransformer||(this.sqlTransformer=new T(this.db)),!this.sqlTransformer)throw new Error("SQL transformer not initialized");let t=await this.getGlueTableViewSetupSql(e),s=await this.sqlTransformer.transformGlueTableQuery(e);return t.join("")+s}async getGlueTableViewSetupSql(e){if(this.db||await this.connect(),!this.db)throw new Error("DB not connected");if(this.sqlTransformer||(this.sqlTransformer=new T(this.db)),!this.sqlTransformer)throw new Error("SQL transformer not initialized");let t=[],s=await this.sqlTransformer.getQueryGlueTableRefs(e);u("Found Glue Table references: %O",s),await Promise.all(s.map(async({database:n,table:a})=>{u("Found Glue Table reference: %s",{database:n,table:a});let o=await this.getTableMetadata(n,a),i=`${n}.${a}`,h=o.table.StorageDescriptor?.Location;if(!h)throw new Error(`No storage location found for ${i}`);let f=(o.table.PartitionKeys||[]).map(g=>g.Name),l=await this.listS3Files(h,f);t.push(`CREATE OR REPLACE TABLE "${i}_s3_files" AS SELECT path FROM (VALUES ${l.map(g=>`('${g.path}')`).join(",")}) t(path);`);let d=await Promise.all(f.map(async g=>`${await this.getPartitionExtractor(g,o)} as ${g}`));t.push(`CREATE OR REPLACE TABLE "${i}_s3_listing" AS SELECT path, ${d.join(", ")} FROM "${i}_s3_files";`);for(let g of f)t.push(`CREATE INDEX IF NOT EXISTS idx_${g} ON "${i}_s3_listing" (${g});`);if(!this.sqlTransformer)throw new Error("SQL transformer not initialized");f=(o.table.PartitionKeys||[]).map(g=>g.Name);let p=await this.sqlTransformer.extractPartitionFilters(e,i,f),b=`SELECT list(path) FROM "${i}_s3_listing"`;p.length>0&&(b+=` WHERE ${p.join(" AND ")}`);let S=this.sqlTransformer.getQueryFilesVarName(n,a);t.push(`SET VARIABLE ${S} = (${b});`);let F=await this.createGlueTableFilesVarSql(n,a);F&&t.push(F);let x=await this.sqlTransformer.getGlueTableViewSql(e);t.push(...x)}));let r=t.map(n=>n.trim());return u(r),r}};0&&(module.exports={GlueTableCache});
